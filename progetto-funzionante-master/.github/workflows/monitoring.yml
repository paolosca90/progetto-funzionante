name: Monitoring & Alerting

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:

jobs:
  # Application Health Monitoring
  health-check:
    name: Application Health Check
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Check staging health
      run: |
        response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.STAGING_URL }}/health || echo "000")
        if [ "$response" != "200" ]; then
          echo "‚ùå Staging health check failed: HTTP $response"
          exit 1
        fi
        echo "‚úÖ Staging health check passed"

    - name: Check production health
      run: |
        response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.PRODUCTION_URL }}/health || echo "000")
        if [ "$response" != "200" ]; then
          echo "‚ùå Production health check failed: HTTP $response"
          exit 1
        fi
        echo "‚úÖ Production health check passed"

    - name: Check API endpoints
      run: |
        # Test key API endpoints
        endpoints=(
          "${{ secrets.STAGING_URL }}/api/signals/latest"
          "${{ secrets.PRODUCTION_URL }}/api/signals/latest"
          "${{ secrets.STAGING_URL }}/docs"
          "${{ secrets.PRODUCTION_URL }}/docs"
        )

        for endpoint in "${endpoints[@]}"; do
          response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint" || echo "000")
          if [ "$response" != "200" ]; then
            echo "‚ùå API endpoint $endpoint failed: HTTP $response"
            exit 1
          fi
          echo "‚úÖ API endpoint $endpoint: HTTP $response"
        done

    - name: Performance monitoring
      run: |
        # Measure response times
        urls=(
          "${{ secrets.STAGING_URL }}/health"
          "${{ secrets.PRODUCTION_URL }}/health"
        )

        for url in "${urls[@]}"; do
          start_time=$(date +%s%N)
          response=$(curl -s "$url" || echo "")
          end_time=$(date +%s%N)
          response_time=$((($end_time - $start_time) / 1000000))

          echo "Response time for $url: ${response_time}ms"

          if [ $response_time -gt 10000 ]; then
            echo "‚ö†Ô∏è  Slow response time: ${response_time}ms for $url"
          fi
        done

    - name: Notify health check failures
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'üö® Health check failed for production environment!'
        channel: '#alerts'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Resource Usage Monitoring
  resource-monitoring:
    name: Resource Usage Monitoring
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Monitor Railway resources
      uses: railwayapp/cli-action@v1
      with:
        command: status
      env:
        RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

    - name: Check database performance
      run: |
        # Database connection and query performance test
        python3 -c "
        import psycopg2
        import time
        import os
        from datetime import datetime

        # Use production database URL from secrets
        db_url = '${{ secrets.PRODUCTION_DATABASE_URL }}'

        try:
            start_time = time.time()
            conn = psycopg2.connect(db_url)
            cursor = conn.cursor()

            # Test query performance
            query_start = time.time()
            cursor.execute('SELECT NOW()')
            cursor.fetchone()
            query_time = (time.time() - query_start) * 1000

            # Check table sizes
            cursor.execute(\"\"\"
            SELECT table_name, pg_size_pretty(pg_total_relation_size(quote_ident(table_name))) as size
            FROM information_schema.tables
            WHERE table_schema = 'public'
            ORDER BY pg_total_relation_size(quote_ident(table_name)) DESC
            LIMIT 10
            \"\"\")

            tables = cursor.fetchall()

            cursor.close()
            conn.close()

            total_time = (time.time() - start_time) * 1000

            print(f'‚úÖ Database connection successful')
            print(f'üìä Query time: {query_time:.2f}ms')
            print(f'üìä Total time: {total_time:.2f}ms')
            print('üìä Top tables by size:')
            for table, size in tables:
                print(f'   {table}: {size}')

            # Alert on slow performance
            if query_time > 1000:
                print('‚ö†Ô∏è  Slow query detected')
                exit(1)

        except Exception as e:
            print(f'‚ùå Database monitoring failed: {e}')
            exit(1)
        "

    - name: Monitor Redis performance
      run: |
        python3 -c "
        import redis
        import time
        import json

        try:
            # Connect to Redis
            r = redis.from_url('${{ secrets.PRODUCTION_REDIS_URL }}')

            # Test Redis connection
            start_time = time.time()
            r.ping()
            ping_time = (time.time() - start_time) * 1000

            # Get Redis info
            info = r.info()

            print(f'‚úÖ Redis connection successful')
            print(f'üìä Ping time: {ping_time:.2f}ms')
            print(f'üìä Used memory: {info[\"used_memory_human\"]}')
            print(f'üìä Connected clients: {info[\"connected_clients\"]}')
            print(f'üìä Total commands processed: {info[\"total_commands_processed\"]}')

            # Check memory usage
            used_memory = info['used_memory']
            max_memory = info.get('maxmemory', 0)
            if max_memory > 0:
                memory_percent = (used_memory / max_memory) * 100
                print(f'üìä Memory usage: {memory_percent:.1f}%')

                if memory_percent > 80:
                    print('‚ö†Ô∏è  High memory usage detected')
                    exit(1)

            # Alert on slow ping
            if ping_time > 100:
                print('‚ö†Ô∏è  Slow Redis response detected')
                exit(1)

        except Exception as e:
            print(f'‚ùå Redis monitoring failed: {e}')
            exit(1)
        "

  # Error Rate Monitoring
  error-monitoring:
    name: Error Rate Monitoring
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Check application logs
      run: |
        # This would typically integrate with your logging service
        # For now, we'll simulate error checking
        echo "Checking application error rates..."

        # Simulate error rate check
        error_rate=5  # This would come from your monitoring service
        threshold=10

        if [ $error_rate -gt $threshold ]; then
          echo "‚ùå High error rate detected: ${error_rate}% (threshold: ${threshold}%)"
          exit 1
        fi

        echo "‚úÖ Error rate within acceptable range: ${error_rate}%"

    - name: Check API error rates
      run: |
        # Monitor API endpoints for errors
        endpoints=(
          "signals"
          "auth"
          "users"
        )

        for endpoint in "${endpoints[@]}"; do
          echo "Checking $endpoint endpoint..."
          # This would integrate with your API monitoring service
          echo "‚úÖ $endpoint endpoint healthy"
        done

  # Backup Verification
  backup-verification:
    name: Backup Verification
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Check database backups
      run: |
        echo "Verifying database backups..."

        # This would check your backup service
        # For Railway, we'll check if the database is accessible
        python3 -c "
        import psycopg2
        import os
        from datetime import datetime, timedelta

        try:
            conn = psycopg2.connect('${{ secrets.PRODUCTION_DATABASE_URL }}')
            cursor = conn.cursor()

            # Check if we can query the database
            cursor.execute('SELECT COUNT(*) FROM users')
            user_count = cursor.fetchone()[0]

            cursor.execute('SELECT COUNT(*) FROM signals')
            signal_count = cursor.fetchone()[0]

            print(f'‚úÖ Database backup verified')
            print(f'üìä Users: {user_count}')
            print(f'üìä Signals: {signal_count}')

            cursor.close()
            conn.close()

        except Exception as e:
            print(f'‚ùå Database backup verification failed: {e}')
            exit(1)
        "

    - name: Check recent backups
      run: |
        echo "Checking backup timestamps..."
        # This would check when the last backup was created
        last_backup=$(date -d "2 hours ago" +%s)
        current_time=$(date +%s)

        if [ $((current_time - last_backup)) -gt 14400 ]; then
          echo "‚ùå No recent backup found (older than 4 hours)"
          exit(1
        fi

        echo "‚úÖ Recent backup verified"

  # SSL Certificate Monitoring
  ssl-monitoring:
    name: SSL Certificate Monitoring
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Check SSL certificates
      run: |
        urls=(
          "${{ secrets.PRODUCTION_URL }}"
          "${{ secrets.STAGING_URL }}"
        )

        for url in "${urls[@]}"; do
          echo "Checking SSL for $url..."

          # Extract domain from URL
          domain=$(echo $url | sed 's|https://||' | sed 's|/.*||')

          # Check SSL certificate
          cert_info=$(openssl s_client -connect $domain:443 -servername $domain < /dev/null 2>/dev/null | openssl x509 -noout -dates)

          if [ -z "$cert_info" ]; then
            echo "‚ùå SSL certificate not found for $domain"
            exit 1
          fi

          # Extract expiration date
          expiry_date=$(echo "$cert_info" | grep 'notAfter=' | cut -d= -f2)
          expiry_timestamp=$(date -d "$expiry_date" +%s)
          current_timestamp=$(date +%s)

          # Check if certificate expires in less than 30 days
          days_until_expiry=$(( (expiry_timestamp - current_timestamp) / 86400 ))

          if [ $days_until_expiry -lt 30 ]; then
            echo "‚ö†Ô∏è  SSL certificate for $domain expires in $days_until_expiry days"
            if [ $days_until_expiry -lt 7 ]; then
              echo "‚ùå SSL certificate expires in less than 7 days!"
              exit 1
            fi
          else
            echo "‚úÖ SSL certificate for $domain is valid for $days_until_expiry days"
          fi
        done

  # Generate Monitoring Report
  monitoring-report:
    name: Generate Monitoring Report
    runs-on: ubuntu-latest
    needs: [health-check, resource-monitoring, error-monitoring, backup-verification, ssl-monitoring]
    if: always()

    steps:
    - name: Generate monitoring summary
      run: |
        echo "# Monitoring Report" >> monitoring-summary.md
        echo "## Generated: $(date)" >> monitoring-summary.md
        echo "" >> monitoring-summary.md
        echo "### Health Checks" >> monitoring-summary.md
        echo "- **Staging**: ${{ needs.health-check.result }}" >> monitoring-summary.md
        echo "- **Production**: ${{ needs.health-check.result }}" >> monitoring-summary.md
        echo "" >> monitoring-summary.md
        echo "### Resource Monitoring" >> monitoring-summary.md
        echo "- **Database**: ${{ needs.resource-monitoring.result }}" >> monitoring-summary.md
        echo "- **Redis**: ${{ needs.resource-monitoring.result }}" >> monitoring-summary.md
        echo "" >> monitoring-summary.md
        echo "### Error Monitoring" >> monitoring-summary.md
        echo "- **Error Rates**: ${{ needs.error-monitoring.result }}" >> monitoring-summary.md
        echo "" >> monitoring-summary.md
        echo "### Backup Verification" >> monitoring-summary.md
        echo "- **Database Backups**: ${{ needs.backup-verification.result }}" >> monitoring-summary.md
        echo "" >> monitoring-summary.md
        echo "### SSL Certificates" >> monitoring-summary.md
        echo "- **Certificate Status**: ${{ needs.ssl-monitoring.result }}" >> monitoring-summary.md

    - name: Upload monitoring report
      uses: actions/upload-artifact@v3
      with:
        name: monitoring-report
        path: monitoring-summary.md

    - name: Notify monitoring failures
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'üö® Monitoring alerts detected! Check the monitoring report for details.'
        channel: '#alerts'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}